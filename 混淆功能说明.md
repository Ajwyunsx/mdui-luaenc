# Lua混淆器功能详细说明

## 🎯 混淆目标
保护Lua源代码的知识产权，防止逆向分析和代码盗用，同时保持代码的功能完整性。

## 🔧 核心混淆技术

### 1. 控制流混淆 (Control Flow Obfuscation)
**原理**：在代码中插入无用的条件分支和循环，打乱原有的执行流程
**实现**：
- 在函数开头和结尾插入条件判断
- 添加永真或永假的if语句
- 插入不影响结果的while循环
- 使用复杂的布尔表达式替代简单条件

**示例**：
```lua
-- 原始代码
function calculate(a, b)
    return a + b
end

-- 混淆后代码
function _0xA1B2(_0xC3D4, _0xE5F6)
    if (1==1) then
        local _0xG7H8 = 0
        while _0xG7H8 < 3 do
            _0xG7H8 = _0xG7H8 + 1
        end
    end
    
    if not false then
        return _0xC3D4 + _0xE5F6
    end
end
```

### 2. 字符串加密 (String Encryption)
**原理**：将字符串常量转换为字符编码数组，运行时动态解密
**实现**：
- 将字符串分解为字符编码数组
- 生成对应的解密函数
- 在运行时动态拼接字符串

**示例**：
```lua
-- 原始代码
local message = "Hello World"

-- 混淆后代码
local _0xDecrypt = function(_0xArray)
    local _0xResult = ""
    for i = 1, #_0xArray do
        _0xResult = _0xResult .. string.char(_0xArray[i])
    end
    return _0xResult
end

local message = _0xDecrypt({72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100})
```

### 3. 数字混淆 (Number Obfuscation)
**原理**：将数字常量转换为等价的复杂数学表达式
**实现**：
- 使用数学运算构造等价表达式
- 结合函数调用和位运算
- 避免使用简单的数字字面量

**示例**：
```lua
-- 原始代码
local count = 42
local flag = 1

-- 混淆后代码
local count = math.floor(math.pi * 13.369) + math.abs(-1)
local flag = #(function() return {1} end)()
```

### 4. 布尔值混淆 (Boolean Obfuscation)
**原理**：将true/false转换为等价的逻辑表达式
**实现**：
- 使用比较运算符构造布尔表达式
- 结合逻辑运算符和函数调用
- 避免直接使用布尔字面量

**示例**：
```lua
-- 原始代码
local enabled = true
local disabled = false

-- 混淆后代码
local enabled = (1==1) and not false
local disabled = not (0==0) or (nil~=nil)
```

### 5. nil值混淆 (Nil Obfuscation)
**原理**：将nil转换为复杂的函数调用或表达式
**实现**：
- 使用函数返回值模拟nil
- 构造返回nil的复杂表达式
- 避免直接使用nil字面量

**示例**：
```lua
-- 原始代码
local value = nil

-- 混淆后代码
local value = (function() return nil end)()
-- 或
local value = not (function() return true end)() and nil
```

### 6. 花指令植入 (Junk Code Injection)
**原理**：随机插入无害的死代码，增加代码复杂度
**实现**：
- 插入不影响结果的do-end块
- 添加无用的局部变量声明
- 插入永假条件的代码块
- 保持10%的随机插入概率

**示例**：
```lua
-- 原始代码
function process(data)
    return data * 2
end

-- 混淆后代码
function _0xProcess(_0xData)
    do
        local _0xTemp = 123
        _0xTemp = _0xTemp + 456
    end
    
    if false then
        print("This will never execute")
    end
    
    return _0xData * 2
end
```

## 📊 混淆强度等级

### 基础混淆 (Basic)
- 局部变量重命名
- 字符串加密
- **适用场景**：简单的代码保护，性能要求高

### 标准混淆 (Standard)
- 基础混淆 + 
- 数字混淆
- 布尔值混淆
- **适用场景**：一般的商业代码保护

### 高级混淆 (Advanced)
- 标准混淆 + 
- 控制流混淆
- 花指令植入
- **适用场景**：重要的核心算法保护

### 极致混淆 (Extreme)
- 所有功能全开
- 最大化代码复杂度
- **适用场景**：高度敏感的知识产权保护

## ⚡ 性能影响

| 混淆等级 | 文件大小增加 | 执行速度影响 | 内存使用 |
|---------|-------------|-------------|---------|
| 基础 | +5-15% | -2-5% | +5% |
| 标准 | +15-30% | -5-10% | +10% |
| 高级 | +30-60% | -10-20% | +20% |
| 极致 | +60-100% | -20-30% | +30% |

## 🔍 兼容性保证

### 支持的Lua版本
- **Lua 5.0**：完全兼容，支持所有混淆功能
- **Lua 5.1**：完全兼容，支持所有混淆功能
- **Lua 5.2**：完全兼容，支持所有混淆功能
- **Lua 5.3**：完全兼容，支持所有混淆功能
- **Lua 5.4**：完全兼容，支持所有混淆功能

### 特殊环境支持
- **GGLua**：支持GG修改器环境
- **AndLua**：支持AndLua+开发环境
- **LuaJIT**：支持即时编译环境

### 语法兼容性
- 保持原有代码语义不变
- 不改变函数的输入输出行为
- 不影响全局变量的访问
- 保持模块加载和require功能

## 🛡️ 安全强度

### 防逆向能力
- **静态分析**：极大增加代码阅读难度
- **动态调试**：干扰调试器的代码跟踪
- **符号恢复**：变量名和字符串无法直接恢复
- **逻辑理解**：控制流混淆使逻辑难以理解

### 破解难度
- **初级破解者**：无法手动分析
- **中级破解者**：需要专业工具和时间
- **高级破解者**：显著增加逆向工程成本

## 💡 使用建议

### 最佳实践
1. **选择合适的混淆等级**：根据代码重要性选择适当等级
2. **保留原始代码**：混淆前备份源代码
3. **测试验证**：混淆后充分测试功能完整性
4. **性能监控**：关注混淆后的性能表现

### 注意事项
- 混淆不是万能的，只是增加逆向难度
- 过度混淆可能影响代码性能
- 某些特殊代码可能不适合混淆
- 建议结合其他安全措施使用

## ✅ 安全模式与可执行性
- 默认启用安全模式（safeMode）：分段解析，避免注释/字符串与代码粘连
- 仅对代码段进行空格规整与布尔/nil混淆；字符串使用 `string.char`
- CLI 用法：`node obfuscate-cli.js input.lua output.lua`
- 默认关闭整数混淆与单行压缩；如需开启，请编辑 `obfuscate-cli.js` 的 `options`
- 验证建议：先用 `simple-test.lua`、`decimal-test.lua` 观察混淆结果
- 常见修复：`<=` 等运算符间距、`--` 行注释换行保留、小数不被误处理